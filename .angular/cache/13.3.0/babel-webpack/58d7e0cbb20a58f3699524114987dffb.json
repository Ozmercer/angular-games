{"ast":null,"code":"import * as i0 from \"@angular/core\";\nexport let BoardService = /*#__PURE__*/(() => {\n  class BoardService {\n    constructor() {\n      this.field = [];\n      this.changed = false;\n      this.BOARD_SIZE = 10;\n      this.toggleMode = false;\n      this.tileSize = 1;\n      this.colSpread = 2;\n      this.rowSpread = 2;\n      this.pattern = 1;\n    }\n\n    initField() {\n      if (typeof Worker !== 'undefined') {\n        // Create a new\n        this.worker = new Worker('./board.worker', {\n          type: 'module'\n        });\n\n        this.worker.onmessage = ({\n          data\n        }) => {\n          if (data.message === 'updateField') {\n            this.changed = data.changed;\n            this.field = data.body;\n          } else {\n            console.log('caught: ' + data.message);\n          }\n        };\n      } else {\n        alert('This app does not work on your browser. Please try a more modern version'); // Web Workers are not supported in this environment.\n        // You should add a fallback so that your program still executes correctly.\n      }\n\n      this.buildField();\n    }\n\n    unregister() {\n      this.initField();\n      this.worker.terminate();\n    }\n\n    calculateField() {\n      // this.worker.postMessage({message: 'updateField', prevField: this.field});\n      const newField = this.buildField();\n      let changed = false;\n      this.field.forEach((cell, index) => {\n        const neighbours = this.livingNeighboursCount(cell);\n        console.log(neighbours);\n\n        if (neighbours < 2) {\n          newField[index].alive = false;\n        } else if (neighbours > 3) {\n          newField[index].alive = false;\n        } else if (neighbours === 3) {\n          newField[index].alive = true;\n        } else if (cell.alive) {\n          newField[index].alive = true;\n        }\n\n        if (!changed && newField[index].alive !== cell.alive) {\n          changed = true;\n        }\n      });\n      console.log(newField);\n      this.field = newField;\n      this.changed = changed;\n    }\n\n    livingNeighboursCount(cell) {\n      let counter = 0;\n\n      for (let i = -1; i <= 1; i++) {\n        for (let j = -1; j <= 1; j++) {\n          if (!(i === 0 && j === 0) && cell.row + i < this.BOARD_SIZE && cell.col + j < this.BOARD_SIZE && cell.row + i >= 0 && cell.col + j >= 0) {\n            counter += this.findCell(cell.row + i, cell.col + j).alive ? 1 : 0;\n          }\n        }\n      }\n\n      return counter;\n    }\n\n    findCell(row, col) {\n      return this.field[row * this.BOARD_SIZE + col];\n    }\n\n    buildField() {\n      // this.worker.postMessage({message: 'buildField', boardSize: this.BOARD_SIZE});\n      this.field = [];\n\n      for (let i = 0; i < this.BOARD_SIZE; i++) {\n        for (let j = 0; j < this.BOARD_SIZE; j++) {\n          this.field.push({\n            row: i,\n            col: j,\n            alive: false\n          });\n        }\n      }\n\n      return this.field;\n    }\n\n    randomFill(fillPercent) {\n      this.field.forEach(cell => {\n        cell.alive = Math.random() < fillPercent / 100;\n      });\n    }\n\n    fillEdges(side = 'all') {\n      const topRow = cell => cell.row === 0;\n\n      const bottomRow = cell => cell.row === this.BOARD_SIZE - 1;\n\n      const leftCol = cell => cell.col === 0;\n\n      const rightCol = cell => cell.col === this.BOARD_SIZE - 1;\n\n      let condition;\n\n      switch (side) {\n        case 'top':\n          condition = cell => topRow(cell);\n\n          break;\n\n        case 'bottom':\n          condition = cell => bottomRow(cell);\n\n          break;\n\n        case 'left':\n          condition = cell => leftCol(cell);\n\n          break;\n\n        case 'right':\n          condition = cell => rightCol(cell);\n\n          break;\n\n        default:\n          condition = cell => topRow(cell) || bottomRow(cell) || leftCol(cell) || rightCol(cell);\n\n      }\n\n      this.field.forEach(cell => {\n        if (condition(cell)) {\n          cell.alive = this.toggleMode ? !cell.alive : true;\n        }\n      });\n    }\n\n    fillX() {\n      this.field.forEach(cell => {\n        if (cell.col === cell.row || cell.col === this.BOARD_SIZE - 1 - cell.row) {\n          cell.alive = this.toggleMode ? !cell.alive : true;\n        }\n      });\n    }\n\n    fillTiles(size) {\n      this.field.forEach(cell => {\n        if (cell.col % size && !(cell.row % size) || cell.row % size && !(cell.col % size)) {\n          cell.alive = this.toggleMode ? !cell.alive : true;\n        }\n      });\n    }\n\n    fillLines(size, isCol = true) {\n      this.field.forEach(cell => {\n        if (cell[isCol ? 'col' : 'row'] % size === 0) {\n          cell.alive = this.toggleMode ? !cell.alive : true;\n        }\n      });\n    }\n\n    fillPatter(size) {\n      this.field.forEach((cell, index) => {\n        cell.alive = index % size === 0;\n      });\n    }\n\n    clearGame() {\n      this.buildField();\n    }\n\n    checkGameOver() {\n      return this.changed === false || !this.field.find(cell => cell.alive);\n    }\n\n  }\n\n  BoardService.ɵfac = function BoardService_Factory(t) {\n    return new (t || BoardService)();\n  };\n\n  BoardService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: BoardService,\n    factory: BoardService.ɵfac,\n    providedIn: 'root'\n  });\n  return BoardService;\n})();","map":null,"metadata":{},"sourceType":"module"}